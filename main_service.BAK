<<<<<<< HEAD
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include "thpool.h"

#define MAX_PIXEL_VALUE 255
#define KERNEL_SIZE 3
#define HISTOGRAM_SIZE 256

typedef unsigned char pixel_t;
=======
// Dynamic Time Warping (DTW) algorithm, which is widely used in speech recognition, time series analysis, and pattern matching.

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <pthread.h>
#include <thpool.h>

#define MAX_SEQUENCE_LENGTH 10000
#define WINDOW_SIZE 100  // Sakoe-Chiba band width
>>>>>>> sb-working

int num_threads = 4;
threadpool thpool;

<<<<<<< HEAD
// Structure to hold image data
typedef struct {
    pixel_t* data;
    int width;
    int height;
} Image;

// Thread task structures
typedef struct {
    Image* input;
    Image* output;
    int start_row;
    int end_row;
} RowTask;

typedef struct {
    Image* input;
    Image* output;
    int start_idx;
    int end_idx;
    pixel_t* lookup;
} HistogramTask;

// Function to create new image
Image* create_image(int width, int height) {
    Image* img = (Image*)malloc(sizeof(Image));
    img->width = width;
    img->height = height;
    img->data = (pixel_t*)calloc(width * height, sizeof(pixel_t));
    return img;
}

// Function to free image
void free_image(Image* img) {
    free(img->data);
    free(img);
}

// Function to get pixel value
pixel_t get_pixel(Image* img, int x, int y) {
    if (x < 0 || x >= img->width || y < 0 || y >= img->height) {
        return 0;
    }
    return img->data[y * img->width + x];
}

// Function to set pixel value
void set_pixel(Image* img, int x, int y, pixel_t value) {
    if (x < 0 || x >= img->width || y < 0 || y >= img->height) {
        return;
    }
    img->data[y * img->width + x] = value;
}

// Sobel edge detection worker function
void sobel_worker(void* arg) {
    RowTask* task = (RowTask*)arg;

    // Sobel kernels
    const int sobel_x[3][3] = {
        {-1, 0, 1},
        {-2, 0, 2},
        {-1, 0, 1}
    };
    const int sobel_y[3][3] = {
        {-1, -2, -1},
        {0, 0, 0},
        {1, 2, 1}
    };

    for (int y = task->start_row; y < task->end_row; y++) {
        for (int x = 1; x < task->input->width - 1; x++) {
            int gx = 0, gy = 0;

            // Apply kernels
            for (int ky = -1; ky <= 1; ky++) {
                for (int kx = -1; kx <= 1; kx++) {
                    pixel_t pixel = get_pixel(task->input, x + kx, y + ky);
                    gx += pixel * sobel_x[ky + 1][kx + 1];
                    gy += pixel * sobel_y[ky + 1][kx + 1];
                }
            }

            // Calculate magnitude
            int magnitude = (int)sqrt(gx * gx + gy * gy);
            magnitude = magnitude > MAX_PIXEL_VALUE ? MAX_PIXEL_VALUE : magnitude;
            set_pixel(task->output, x, y, (pixel_t)magnitude);
        }
    }

    free(task);
}

// Sobel edge detection
Image* sobel_edge_detection(Image* input) {
    Image* output = create_image(input->width, input->height);

    int rows_per_thread = (input->height - 2) / num_threads;

    for (int i = 0; i < num_threads; i++) {
        RowTask* task = (RowTask*)malloc(sizeof(RowTask));
        task->input = input;
        task->output = output;
        task->start_row = 1 + i * rows_per_thread;
        task->end_row = (i == num_threads - 1) ? input->height - 1 : 1 + (i + 1) * rows_per_thread;

        thpool_add_work(thpool, sobel_worker, task);
    }

    thpool_wait(thpool);

    return output;
}

// Gaussian blur worker function
void gaussian_worker(void* arg) {
    RowTask* task = (RowTask*)arg;

    // Gaussian kernel (3x3)
    const float kernel[3][3] = {
        {1.0/16, 2.0/16, 1.0/16},
        {2.0/16, 4.0/16, 2.0/16},
        {1.0/16, 2.0/16, 1.0/16}
    };

    for (int y = task->start_row; y < task->end_row; y++) {
        for (int x = 1; x < task->input->width - 1; x++) {
            float sum = 0.0;

            // Apply kernel
            for (int ky = -1; ky <= 1; ky++) {
                for (int kx = -1; kx <= 1; kx++) {
                    pixel_t pixel = get_pixel(task->input, x + kx, y + ky);
                    sum += pixel * kernel[ky + 1][kx + 1];
                }
            }

            set_pixel(task->output, x, y, (pixel_t)sum);
        }
    }

    free(task);
}

// Gaussian blur
Image* gaussian_blur(Image* input) {
    Image* output = create_image(input->width, input->height);

    int rows_per_thread = (input->height - 2) / num_threads;

    for (int i = 0; i < num_threads; i++) {
        RowTask* task = (RowTask*)malloc(sizeof(RowTask));
        task->input = input;
        task->output = output;
        task->start_row = 1 + i * rows_per_thread;
        task->end_row = (i == num_threads - 1) ? input->height - 1 : 1 + (i + 1) * rows_per_thread;

        thpool_add_work(thpool, gaussian_worker, task);
    }

    thpool_wait(thpool);

    return output;
}

// Histogram equalization worker function
void histogram_worker(void* arg) {
    HistogramTask* task = (HistogramTask*)arg;

    for (int i = task->start_idx; i < task->end_idx; i++) {
        task->output->data[i] = task->lookup[task->input->data[i]];
    }

    free(task);
}

// Histogram equalization
Image* histogram_equalization(Image* input) {
    int histogram[HISTOGRAM_SIZE] = {0};
    float cdf[HISTOGRAM_SIZE] = {0.0};
    int pixel_count = input->width * input->height;
    Image* output = create_image(input->width, input->height);

    // Calculate histogram
    for (int i = 0; i < pixel_count; i++) {
        histogram[input->data[i]]++;
    }

    // Calculate cumulative distribution function
    cdf[0] = histogram[0];
    for (int i = 1; i < HISTOGRAM_SIZE; i++) {
        cdf[i] = cdf[i-1] + histogram[i];
    }

    // Normalize CDF
    for (int i = 0; i < HISTOGRAM_SIZE; i++) {
        cdf[i] /= pixel_count;
    }

    // Apply equalization using lookup table (parallelizable)
    pixel_t* lookup = (pixel_t*)malloc(HISTOGRAM_SIZE * sizeof(pixel_t));
    for (int i = 0; i < HISTOGRAM_SIZE; i++) {
        lookup[i] = (pixel_t)(cdf[i] * MAX_PIXEL_VALUE);
    }

    int pixels_per_thread = pixel_count / num_threads;

    for (int i = 0; i < num_threads; i++) {
        HistogramTask* task = (HistogramTask*)malloc(sizeof(HistogramTask));
        task->input = input;
        task->output = output;
        task->lookup = lookup;
        task->start_idx = i * pixels_per_thread;
        task->end_idx = (i == num_threads - 1) ? pixel_count : (i + 1) * pixels_per_thread;

        thpool_add_work(thpool, histogram_worker, task);
    }

    thpool_wait(thpool);

    free(lookup);

    return output;
}

// Dilation worker function
void dilate_worker(void* arg) {
    RowTask* task = (RowTask*)arg;

    for (int y = task->start_row; y < task->end_row; y++) {
        for (int x = 1; x < task->input->width - 1; x++) {
            pixel_t max_value = 0;

            // Find maximum in 3x3 neighborhood
            for (int ky = -1; ky <= 1; ky++) {
                for (int kx = -1; kx <= 1; kx++) {
                    pixel_t pixel = get_pixel(task->input, x + kx, y + ky);
                    if (pixel > max_value) {
                        max_value = pixel;
                    }
                }
            }

            set_pixel(task->output, x, y, max_value);
        }
    }

    free(task);
}

// Morphological dilation
Image* dilate(Image* input) {
    Image* output = create_image(input->width, input->height);

    int rows_per_thread = (input->height - 2) / num_threads;

    for (int i = 0; i < num_threads; i++) {
        RowTask* task = (RowTask*)malloc(sizeof(RowTask));
        task->input = input;
        task->output = output;
        task->start_row = 1 + i * rows_per_thread;
        task->end_row = (i == num_threads - 1) ? input->height - 1 : 1 + (i + 1) * rows_per_thread;

        thpool_add_work(thpool, dilate_worker, task);
    }

    thpool_wait(thpool);

    return output;
}

// Erosion worker function
void erode_worker(void* arg) {
    RowTask* task = (RowTask*)arg;

    for (int y = task->start_row; y < task->end_row; y++) {
        for (int x = 1; x < task->input->width - 1; x++) {
            pixel_t min_value = MAX_PIXEL_VALUE;

            // Find minimum in 3x3 neighborhood
            for (int ky = -1; ky <= 1; ky++) {
                for (int kx = -1; kx <= 1; kx++) {
                    pixel_t pixel = get_pixel(task->input, x + kx, y + ky);
                    if (pixel < min_value) {
                        min_value = pixel;
                    }
                }
            }

            set_pixel(task->output, x, y, min_value);
        }
    }

    free(task);
}

// Morphological erosion
Image* erode(Image* input) {
    Image* output = create_image(input->width, input->height);

    int rows_per_thread = (input->height - 2) / num_threads;

    for (int i = 0; i < num_threads; i++) {
        RowTask* task = (RowTask*)malloc(sizeof(RowTask));
        task->input = input;
        task->output = output;
        task->start_row = 1 + i * rows_per_thread;
        task->end_row = (i == num_threads - 1) ? input->height - 1 : 1 + (i + 1) * rows_per_thread;

        thpool_add_work(thpool, erode_worker, task);
    }

    thpool_wait(thpool);

    return output;
}

// Function to apply all transformations in sequence
Image* process_image(Image* input) {
    Image* temp1, *temp2, *temp3, *temp4, *result;

    // Apply gaussian blur first to reduce noise
    temp1 = gaussian_blur(input);

    // Apply edge detection
    temp2 = sobel_edge_detection(temp1);

    // Enhance edges through histogram equalization
    temp3 = histogram_equalization(temp2);

    // Apply morphological operations to clean up edges
    temp4 = dilate(temp3);
    result = erode(temp4);

    // Clean up intermediate results
    free_image(temp1);
    free_image(temp2);
    free_image(temp3);
    free_image(temp4);
=======
// Structure to store DTW result
typedef struct {
    double distance;
    int* path_i;
    int* path_j;
    int path_length;
} DTWResult;

// Function to generate random sequence
void generate_sequence(double* sequence, int length) {
    for(int i = 0; i < length; i++) {
        sequence[i] = ((double)rand() / RAND_MAX) * 100.0;
    }
}

// Function to calculate Euclidean distance
double calculate_distance(double a, double b) {
    return (a - b) * (a - b);
}

// Function to find minimum of three values
double min3(double a, double b, double c) {
    return fmin(fmin(a, b), c);
}

// Main DTW implementation with windowing
DTWResult* compute_dtw(double* sequence1, int len1, 
                      double* sequence2, int len2) {
    // Allocate cost matrix
    double** cost_matrix = (double**)malloc(len1 * sizeof(double*));
    for(int i = 0; i < len1; i++) {
        cost_matrix[i] = (double*)malloc(len2 * sizeof(double));
        for(int j = 0; j < len2; j++) {
            cost_matrix[i][j] = DBL_MAX;
        }
    }

    // Initialize first element
    cost_matrix[0][0] = calculate_distance(sequence1[0], sequence2[0]);

    // Initialize first row and column
    for(int i = 1; i < len1; i++) {
        if(i <= WINDOW_SIZE) {
            cost_matrix[i][0] = cost_matrix[i-1][0] + 
                               calculate_distance(sequence1[i], sequence2[0]);
        }
    }
    for(int j = 1; j < len2; j++) {
        if(j <= WINDOW_SIZE) {
            cost_matrix[0][j] = cost_matrix[0][j-1] + 
                               calculate_distance(sequence1[0], sequence2[j]);
        }
    }

    // Fill cost matrix with windowing (Sakoe-Chiba band)
    for(int i = 1; i < len1; i++) {
        int start = (i - WINDOW_SIZE > 1) ? i - WINDOW_SIZE : 1;
        int end = (i + WINDOW_SIZE < len2) ? i + WINDOW_SIZE : len2;
        
        for(int j = start; j < end; j++) {
            double cost = calculate_distance(sequence1[i], sequence2[j]);
            cost_matrix[i][j] = cost + min3(
                cost_matrix[i-1][j],    // insertion
                cost_matrix[i][j-1],    // deletion
                cost_matrix[i-1][j-1]   // match
            );
        }
    }

    // Backtracking to find optimal path
    DTWResult* result = (DTWResult*)malloc(sizeof(DTWResult));
    result->path_i = (int*)malloc((len1 + len2) * sizeof(int));
    result->path_j = (int*)malloc((len1 + len2) * sizeof(int));
    
    int path_index = 0;
    int i = len1 - 1;
    int j = len2 - 1;
    
    while(i > 0 || j > 0) {
        result->path_i[path_index] = i;
        result->path_j[path_index] = j;
        path_index++;
        
        if(i == 0) {
            j--;
        } else if(j == 0) {
            i--;
        } else {
            double min_cost = min3(
                cost_matrix[i-1][j],
                cost_matrix[i][j-1],
                cost_matrix[i-1][j-1]
            );
            
            if(min_cost == cost_matrix[i-1][j-1]) {
                i--; j--;
            } else if(min_cost == cost_matrix[i-1][j]) {
                i--;
            } else {
                j--;
            }
        }
    }
    
    // Add final point
    result->path_i[path_index] = 0;
    result->path_j[path_index] = 0;
    path_index++;
    
    result->path_length = path_index;
    result->distance = cost_matrix[len1-1][len2-1];

    // Free cost matrix
    for(int i = 0; i < len1; i++) {
        free(cost_matrix[i]);
    }
    free(cost_matrix);
>>>>>>> sb-working

    return result;
}

<<<<<<< HEAD
int main_worker(int argc, char * argv[]) {

    int size = atoi(argv[1]);
    int IMG_WIDTH = size;
    int IMG_HEIGHT = size;

    num_threads = atoi(argv[argc-2]);

    // Initialize threadpool
    thpool = thpool_init(num_threads);

    // Create test image with random noise
    Image* input = create_image(IMG_WIDTH, IMG_HEIGHT);
    for (int i = 0; i < IMG_WIDTH * IMG_HEIGHT; i++) {
        input->data[i] = rand() % (MAX_PIXEL_VALUE + 1);
    }

    // Process image and measure time
    clock_t start = clock();
    Image* output = process_image(input);
    clock_t end = clock();

    double cpu_time = ((double) (end - start)) / CLOCKS_PER_SEC;
    printf("Processing time: %f seconds\n", cpu_time);

    // Clean up
    free_image(input);
    free_image(output);
=======
// Thread data structure for threadpool
typedef struct {
    double* long_sequence;
    int long_length;
    double* pattern;
    int pattern_length;
    int start_idx;
    int end_idx;
    double best_distance;
    int best_position;
    pthread_mutex_t* mutex;
} ThreadPoolTaskData;

// Worker function for threadpool
void threadpool_worker(void* arg) {
    ThreadPoolTaskData* data = (ThreadPoolTaskData*)arg;

    double local_best_distance = DBL_MAX;
    int local_best_position = data->start_idx;

    for(int i = data->start_idx; i < data->end_idx; i++) {
        // Extract subsequence
        double* subsequence = (double*)malloc(data->pattern_length * sizeof(double));
        for(int j = 0; j < data->pattern_length; j++) {
            subsequence[j] = data->long_sequence[i + j];
        }

        // Compute DTW
        DTWResult* result = compute_dtw(subsequence, data->pattern_length,
                                      data->pattern, data->pattern_length);

        // Update local best match if necessary
        if(result->distance < local_best_distance) {
            local_best_distance = result->distance;
            local_best_position = i;
        }

        // Cleanup
        free(subsequence);
        free(result->path_i);
        free(result->path_j);
        free(result);
    }

    // Update global best with mutex protection
    pthread_mutex_lock(data->mutex);
    if(local_best_distance < data->best_distance) {
        data->best_distance = local_best_distance;
        data->best_position = local_best_position;
    }
    pthread_mutex_unlock(data->mutex);

    free(data);
}

// Function to perform subsequence DTW search (threadpool version)
int find_best_match(double* long_sequence, int long_length,
                   double* pattern, int pattern_length,
                   double* best_distance) {
    int num_iterations = long_length - pattern_length + 1;

    // Shared state for results
    pthread_mutex_t result_mutex = PTHREAD_MUTEX_INITIALIZER;
    double global_best_distance = DBL_MAX;
    int global_best_position = 0;

    int chunk_size = num_iterations / num_threads;

    // Add work to threadpool
    for(int t = 0; t < num_threads; t++) {
        ThreadPoolTaskData* task_data = (ThreadPoolTaskData*)malloc(sizeof(ThreadPoolTaskData));
        task_data->long_sequence = long_sequence;
        task_data->long_length = long_length;
        task_data->pattern = pattern;
        task_data->pattern_length = pattern_length;
        task_data->start_idx = t * chunk_size;

        if(t == num_threads - 1) {
            task_data->end_idx = num_iterations;
        } else {
            task_data->end_idx = (t + 1) * chunk_size;
        }

        task_data->best_distance = global_best_distance;
        task_data->best_position = global_best_position;
        task_data->mutex = &result_mutex;

        thpool_add_work(thpool, threadpool_worker, (void*)task_data);
    }

    // Wait for all work to complete
    thpool_wait(thpool);

    // Get the final results (read from the shared variables through the mutex)
    pthread_mutex_lock(&result_mutex);
    *best_distance = global_best_distance;
    int best_position = global_best_position;
    pthread_mutex_unlock(&result_mutex);

    pthread_mutex_destroy(&result_mutex);

    return best_position;
}

int main_worker(int argc, char * argv[]) {

    srand(time(NULL));

    // Generate sample sequences
    int long_length = atoi(argv[1]);
    int pattern_length = 500;

     num_threads = atoi(argv[argc-2]);
    // Create threadpool
    thpool = thpool_init(num_threads);
    
    double* long_sequence = (double*)malloc(long_length * sizeof(double));
    double* pattern = (double*)malloc(pattern_length * sizeof(double));
    
    generate_sequence(long_sequence, long_length);
    generate_sequence(pattern, pattern_length);

    // Measure execution time
    clock_t start = clock();
    
    // Find best matching subsequence
    double best_distance;
    int best_position = find_best_match(long_sequence, long_length,
                                      pattern, pattern_length,
                                      &best_distance);
    
    clock_t end = clock();
    double cpu_time = ((double) (end - start)) / CLOCKS_PER_SEC;

    // Print results
    printf("Best match found at position: %d\n", best_position);
    printf("Distance: %f\n", best_distance);
    printf("Execution time: %f seconds\n", cpu_time);

    // Cleanup
    free(long_sequence);
    free(pattern);

    // Cleanup
>>>>>>> sb-working
    thpool_destroy(thpool);

    return 0;
}
